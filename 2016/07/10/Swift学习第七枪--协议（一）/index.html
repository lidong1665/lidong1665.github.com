<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Swift学习第七枪--协议（一） | 李东的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="协议（Protocols）协议 定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为 遵循(conform) 这个协议。

协议的语法（Protocol Syntax）


对属性的规定（Property Requirements）


对方法的规定（Method Req">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift学习第七枪--协议（一）">
<meta property="og:url" content="http://lidong1665.github.io/2016/07/10/Swift学习第七枪--协议（一）/index.html">
<meta property="og:site_name" content="李东的个人博客">
<meta property="og:description" content="协议（Protocols）协议 定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为 遵循(conform) 这个协议。

协议的语法（Protocol Syntax）


对属性的规定（Property Requirements）


对方法的规定（Method Req">
<meta property="og:updated_time" content="2016-07-10T08:33:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift学习第七枪--协议（一）">
<meta name="twitter:description" content="协议（Protocols）协议 定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为 遵循(conform) 这个协议。

协议的语法（Protocol Syntax）


对属性的规定（Property Requirements）


对方法的规定（Method Req">
<meta name="twitter:creator" content="@[object Object]">
  
    <link rel="alternate" href="/atom.xml" title="李东的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="imgs/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">李东的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">细节决定成功，点滴铸就辉煌。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">个人主页</a>
        
          <a class="main-nav-link" href="/archives">博客档案</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lidong1665.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Swift学习第七枪--协议（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/10/Swift学习第七枪--协议（一）/" class="article-date">
  <time datetime="2016-07-10T08:32:13.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Swift学习第七枪--协议（一）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="协议（Protocols）"><a href="#协议（Protocols）" class="headerlink" title="协议（Protocols）"></a>协议（Protocols）</h1><p>协议 定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为 遵循(confor<br>m) 这个协议。</p>
<ul>
<li>协议的语法（Protocol Syntax）</li>
</ul>
<ul>
<li>对属性的规定（Property Requirements）</li>
</ul>
<ul>
<li>对方法的规定（Method Requirements）</li>
</ul>
<ul>
<li>对Mutating方法的规定（Mutating Method Requirements）</li>
</ul>
<ul>
<li>对构造器的规定（Initializer Requirements）</li>
</ul>
<ul>
<li>协议类型（Protocols as Types）</li>
</ul>
<ul>
<li>委托(代理)模式（Delegation）</li>
</ul>
<ul>
<li>在扩展中添加协议成员（Adding Protocol Conformance with an Extension）</li>
</ul>
<ul>
<li>通过扩展补充协议声明（Declaring Protocol Adoption with an Extension）</li>
</ul>
<ul>
<li>集合中的协议类型（Collections of Protocol Types）</li>
</ul>
<ul>
<li>协议的继承（Protocol Inheritance）</li>
</ul>
<ul>
<li>类专属协议（Class-Only Protocol）</li>
</ul>
<ul>
<li>协议合成（Protocol Composition）</li>
</ul>
<ul>
<li>检验协议的一致性（Checking for Protocol Conformance）</li>
</ul>
<ul>
<li>对可选协议的规定（Optional Protocol Requirements）</li>
</ul>
<ul>
<li>协议扩展（Protocol Extensions）</li>
</ul>
<p>##1.协议的语法<br>协议的定义方式与类，结构体，枚举的定义非常相似。</p>
<pre><code>protocol SomeProtocol {
// 协议内容
}
</code></pre><p>要使类遵循某个协议，需要在类型名称后加上协议名称，中间以冒号 : 分隔，作为类型定义的一部分。遵循多个协议时，各协议之间用逗号 , 分隔。</p>
<pre><code>struct SomeStructure: FirstProtocol, AnotherProtocol {
// 结构体内容
}
</code></pre><p>如果类在遵循协议的同时拥有父类，应该将父类名放在协议名之前，以逗号分隔。</p>
<pre><code>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
// 类的内容
}
</code></pre><p>##2.对属性的规定<br>协议可以规定其 遵循者 提供特定名称和类型的 实例属性(instance property) 或 类属性(type property) ，而不指定是 存储型属性(stored property) 还是 计算型属性(calculate property) 。此外还必须指明是只读的还是可读可写的。</p>
<p>如果协议规定属性是可读可写的，那么这个属性不能是常量或只读的计算属性。如果协议只要求属性是只读的(gettable)，那个属性不仅可以是只读的，如果你代码需要的话，也可以是可写的。</p>
<p>协议中的通常用var来声明属性，在类型声明后加上 { set get } 来表示属性是可读可写的，只读属性则用 { get} 来表示。</p>
<pre><code>protocol SomeProtocol {
var mustBeSettable : Int { get set }
var doesNotNeedToBeSettable: Int { get }
}
</code></pre><p>在协议中定义类属性(type property)时，总是使用 static 关键字作为前缀。当协议的遵循者是类时，可以使用 class 或 static 关键字来声明类属性，但是在协议的定义中，仍然要使用 static 关键字。</p>
<pre><code>protocol AnotherProtocol {
static var someTypeProperty: Int { get set }
}
</code></pre><p>如下所示，这是一个含有一个实例属性要求的协议。</p>
<pre><code>protocol FullyNamed {
var fullName: String { get }
}
</code></pre><p>FullyNamed 协议除了要求协议的遵循者提供fullName属性外，对协议对遵循者的类型并没有特别的要求。这个协议表示，任何遵循 FullyNamed 协议的类型，都具有一个可读的 String 类型实例属性 fullName 。</p>
<p>下面是一个遵循 FullyNamed 协议的简单结构体。</p>
<pre><code>struct Person: FullyNamed{
var fullName: String
}
let john = Person(fullName: &quot;John Appleseed&quot;)
//john.fullName 为 &quot;John Appleseed&quot;
</code></pre><p>这个例子中定义了一个叫做 Person 的结构体，用来表示具有名字的人。从第一行代码中可以看出，它遵循了 FullyNamed 协议。</p>
<p>Person 结构体的每一个实例都有一个叫做 fullName ， String 类型的存储型属性。这正好满足了 FullyNamed 协议的要求，也就意味着，Person 结构体完整的 遵循 了协议。(如果协议要求未被完全满足,在编译时会报错)</p>
<p>下面是一个更为复杂的类，它采用并遵循了 FullyNamed 协议:</p>
<pre><code>class Starship: FullyNamed {
var prefix: String?
var name: String
init(name: String, prefix: String? = nil) {
self.name = name
self.prefix = prefix
}
var fullName: String {
return (prefix != nil ? prefix! + &quot; &quot; : &quot;&quot;) + name
}
}
var ncc1701 = Starship(name: &quot;Enterprise&quot;, prefix: &quot;USS&quot;)
// ncc1701.fullName is &quot;USS Enterprise&quot;
</code></pre><p>Starship类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的属性和一个名为 prefix 的可选属性。 当 prefix 存在时，将 prefix 插入到 name 之前来为Starship构建 fullName ， prefix 不存在时，则将直接用 name 构建 fullName 。</p>
<h2 id="3-对方法的规定"><a href="#3-对方法的规定" class="headerlink" title="3.对方法的规定"></a>3.对方法的规定</h2><p>协议可以要求其遵循者实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通的方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相<br>同。但是在协议的方法定义中，不支持参数默认值。</p>
<p>正如对属性的规定中所说的，在协议中定义类方法的时候，总是使用 static 关键字作为前缀。当协议的遵循者是类的时候，虽然你可以在类的实现中使用 class 或者 static 来实现类方法，但是在协议中声明类方法，仍然要使用 static 关键字。</p>
<pre><code>protocol SomeProtocol {
static func someTypeMethod()
}
</code></pre><p>下面的例子定义了含有一个实例方法的协议。</p>
<pre><code>protocol RandomNumberGenerator {
func random() -&gt; Double
}
</code></pre><p>RandomNumberGenerator 协议要求其遵循者必须拥有一个名为 random ， 返回值类型为 Double 的实例方法。尽管这里并未指明，但是我们假设返回值在[0，1)区间内。</p>
<p>RandomNumberGenerator 协议并不在意每一个随机数是怎样生成的，它只强调这里有一个随机数生成器。</p>
<p>如下所示，下边的是一个遵循了 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器(linear congruential generator) 的伪随机数算法。</p>
<pre><code>class LinearCongruentialGenerator: RandomNumberGenerator {
var lastRandom = 42.0
let m = 139968.0
let a = 3877.0
let c = 29573.0
func random() -&gt; Double {
lastRandom = ((lastRandom * a + c) % m)
return lastRandom / m
}
}
let generator = LinearCongruentialGenerator()
print(&quot;Here&apos;s a random number: \(generator.random())&quot;)
// 输出 : &quot;Here&apos;s a random number: 0.37464991998171&quot;
print(&quot;And another one: \(generator.random())&quot;)
// 输出 : &quot;And another one: 0.729023776863283&quot;
</code></pre><h2 id="4-对Mutating方法的规定"><a href="#4-对Mutating方法的规定" class="headerlink" title="4.对Mutating方法的规定"></a>4.对Mutating方法的规定</h2><p>有时需要在方法中改变它的实例。例如，值类型(结构体，枚举)的实例方法中，将 mutating 关键字作为函数的前缀，写在 func 之前，表示可以在该方法中修改它所属的实例及其实例属性的值。</p>
<p>如果你在协议中定义了一个方法旨在改变遵循该协议的实例，那么在协议定义时需要在方法前加 mutating 关键字。这使得结构和枚举遵循协议并满足此方法要求。</p>
<p>注意:<br>用类实现协议中的 mutating 方法时，不用写 mutating 关键字;用结构体，枚举实现协议中的 mutating 方法时，必须写 mutating 关键字。<br>如下所示， Togglable 协议含有名为 toggle 的实例方法。根据名称推测， toggle() 方法将通过改变实例属性，来切换遵循该协议的实例的状态。</p>
<p>toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时该方法将会改变协议遵循者实例的状态。</p>
<pre><code>protocol Togglable {
mutating func toggle()
}
</code></pre><p>当使用 枚举 或 结构体 来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle 方法。</p>
<p>下面定义了一个名为 OnOffSwitch 的枚举类型。这个枚举类型在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举类型的 toggle 方法被标记为 mutating 以满足 Togglable 协议的要求。</p>
<pre><code>enum OnOffSwitch: Togglable {
case Off, On
mutating func toggle() {
switch self {
case Off:
self = On
case On:
self = Off
}
}
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
//lightSwitch 现在的值为 .On
</code></pre><p>##5.对构造器的规定 ##<br>协议可以要求它的遵循者实现指定的构造器。你可以像书写普通的构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>
<pre><code>protocol SomeProtocol {
init(someParameter: Int)
}
</code></pre><p>###5.1 协议构造器规定在类中的实现<br>你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器(designated initializer)或者便利构造器(convenience initializer)。在这两种情况下，你都必须给构造器实现上”required”修饰符：</p>
<pre><code>class SomeClass: SomeProtocol {
required init(someParameter: Int) {
//构造器实现
}
}
</code></pre><p>使用 required 修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现。</p>
<p>注意：<br>如果类已经被标记为 final ，那么不需要在协议构造器的实现中使用 required 修饰符。因为final类不能有子类。</p>
<p>如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示 required 和 override 修饰符</p>
<pre><code>protocol SomeProtocol {
init()
}
class SomeSuperClass {
init() {
// 构造器的实现
}
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
// 因为遵循协议，需要加上&quot;required&quot;; 因为继承自父类，需要加上&quot;override&quot;
required override init() {
// 构造器实现
}
}
</code></pre><p>###5.2可失败构造器的规定<br>可以通过给协议 Protocols 中添加可失败构造器 (页 0)来使遵循该协议的类型必须实现该可失败构造器。</p>
<p>如果在协议中定义一个可失败构造器，则在遵顼该协议的类型中必须添加同名同参数的可失败构造器或非可失败</p>
<p>构造器。如果在协议中定义一个非可失败构造器，则在遵循该协议的类型中必须添加同名同参数的非可失败构造器或隐式解析类型的可失败构造器（ init! ）。</p>
<h2 id="6-协议类型"><a href="#6-协议类型" class="headerlink" title="6. 协议类型"></a>6. 协议类型</h2><p>尽管协议本身并不实现任何功能，但是协议可以被当做类型来使用。</p>
<p>协议可以像其他普通类型一样使用，使用场景:</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
</ul>
<ul>
<li>作为常量、变量或属性的类型</li>
</ul>
<ul>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<p>注意：<br>协议是一种类型，因此协议类型的名称应与其他类型(Int，Double，String)的写法相同，使用大写字母开头的驼峰式写法，例( FullyNamed 和 RandomNumberGenerator )如下所示，这个示例中将协议当做类型来使用</p>
<pre><code>class Dice {
let sides: Int
let generator: RandomNumberGenerator
init(sides: Int, generator: RandomNumberGenerator) {
self.sides = sides
self.generator = generator
}
func roll() -&gt; Int {
return Int(generator.random() * Double(sides)) + 1
}
}
</code></pre><p>例子中定义了一个 Dice 类，用来代表桌游中的拥有N个面的骰子。 Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器。</p>
<p>generator 属性的类型为 RandomNumberGenerator ，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给generator ，除此之外，无其他要求。</p>
<p>Dice 类中也有一个构造器(initializer)，用来进行初始化操作。构造器中含有一个名为 generator ，类型为 RandomNumberGenerator 的形参。在调用构造方法时创建 Dice 的实例时，可以传入任何遵循RandomNumberGenerator 协议的实例给generator。</p>
<p>Dice 类也提供了一个名为 roll 的实例方法用来模拟骰子的面值。它先使用 generator 的 random() 方法来创建一个[0,1)区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为generator遵循了 RandomNumberGenerator 协议，因而保证了 random 方法可以被调用。<br>下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器创建一个六面骰子:</p>
<pre><code>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
print(&quot;Random dice roll is \(d6.roll())&quot;)
}
//输出结果
//Random dice roll is 3
//Random dice roll is 5
//Random dice roll is 4
//Random dice roll is 5
//Random dice roll is 4
</code></pre><p>总结:这篇就今天就写到协议类型，下篇从委托(代理)模式开始总结。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lidong1665.github.io/2016/07/10/Swift学习第七枪--协议（一）/" data-id="ciqgckssw0006pux2atd8wbxm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/10/Swift学习第八枪--协议（二）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Swift学习第七枪--协议（二）</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 李东<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">个人主页</a>
  
    <a href="/archives" class="mobile-nav-link">博客档案</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>